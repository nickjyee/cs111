# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Nicholas Yee
Student ID: 803946252
Email: njyee@ucla.edu

# Partner 2 (if you're working in a team)
Name: Thomas Lutton
Student ID: 304180703
Email: tlutton@ucla.edu

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)

Run each task (i.e., download or upload) in a child process. Start all tasks 
before waiting for any of them to exit, so that the tasks run in parallel. 
Process uploads once all downloads are done.


# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)

Setting a task's filename with strcpy will cause buffer overrun if the source 
string is longer than FILENAMESIZ bytes. We fixed this problem by setting the 
filename with strncpy to limit the amount of data copied to FILENAMESIZ bytes.

osp2p_snscanf(t->buf, t->tail, "GET %s OSP2P\n", t->filename)
^ This line of code in task_upload will overrun the t->filename buffer if 
the name specified in the GET remote procedure call is longer than 
FILENAMESIZ bytes. To fix this, after calling osp2p_snscanf, set the last byte 
of the t->filename buffer to a null byte. This will prevent bad memory access 
when referencing t->filename. However, it will not fix data that was 
overwitten by the buffer overrun.


# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

Limit the amount of data that can be downloaded in one file to prevent 
peers from filling up our disk. The number of bytes downloaded is equal to 
t->head, so stop copying data from the task buffer to disk once t->head exceeds 
DOWNLOADLIMIT.

Do not serve requests for filenames that contain '/' to avoid serving files 
outside of the current directory or in one of the current directory's 
subdirectories.

There is also a problem when using the popular tracker. The popular tracker
contains many peers that are ready to serve the file. In fact, there are
so many peers that want to serve the file, that the messages that the
tracker sends back over flow the task buffer. A simple fix of this problem
is to increase TASKBUFSIZE beyond 4096 to a much larger number. We chose
16384 which is 4x larger than the original value. The actual bug itself 
occurs within read_tracker_response. This function trusts the tracker
to terminate its write before the buffer fills, but this obviously not the
case. A better solution is to not allow the tracker to overwrite the buffer.
The code could throw an error, or it could just cut off the task.  


# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

If Peer 1 is serving a file to Peer 2, Peer 2 will continue to download data 
as long as Peer 1 continues to upload. Since Peer 2 also trusts that Peer 1 
will send the requested file, we can fill the disk of Peer 1 by writing
infinitely. Accordingly, Peer 1 can fill Peer 2's disk by endlessly 
uploading garbage data. In "evil mode," our peer responds to upload 
requests by writing a character buffer to the pipe in a loop, which exits 
only when the write attempt fails. The recipient will download the data 
until its disk is full.


# Extra credit problems
#Extra credit problem: File Integrity

In order to verify the file integrity of download images, we implemented
MD5 checksums. Since clients must tell the server the MD5 checksums of
their files, we can get the checksum of that file as it is presented
to the tracker and then compare that with the checksum that we actually
downloaded. If the checksums do not match, then we were served a tampered
file. First we check and save the checksum of the file that we are 
attempting to download (within start_download). In order to do this, we "poked
around" within the tracker using Telnet and found how to access the checksum
that the tracker stores for each file. Then, once the download is
complete, we compare the checksum of the file that we actually downloaded
with the checksum that we saved before the download (within task_download).
In order to obtain this second checksum, we need to compute it using the
md5 functions that are provided in md5.h. 

# Add any other information you'd like us to know below this line.
